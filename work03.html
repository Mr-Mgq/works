<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // console.log(Math.PI)
        // // 2的3次方
        // console.log(Math.pow(2,3))
        // // 0-1之间的随机数
        // console.log(Math.random())
        // // 0-10之间的随机数
        // console.log(Math.random()*10)
        // // 0-10之间的随机整数
        // console.log(Math.floor(Math.random()*10))


        // 作用域
        // name = "lwy";
        // function t() {
        //     var name = "tlwy";
        //     function s() {
        //         var name = "slwy";
        //         console.log(name);
        //     }
        //     function ss() {
        //         console.log(name);
        //     }
        //     s();
        //     ss();
        // }
        // t();

        // 闭包
        // function fun(){
        //     var num=100;
        //     function subfun(){//内部函数
        //         console.log(num)//100
        //     }
        //     return subfun;//返回函数
        // }
        // var result=fun();//返回函数
        // result();//100
        // 闭包优点：
        // 1.可以隐藏变量，避免全局变量污染
        // 2.可以实现数据的封装，让外部无法访问内部数据
        // 3.可以实现数据的共享，让多个函数共享同一个数据
        // 4.可以实现数据的缓存，避免重复计算
        // 5.可以实现模块化开发，让代码更加清晰
        // 6.可以实现递归调用，避免栈溢出
        // 闭包缺点：
        // 1.会增加内存消耗，因为内部函数会保留外部函数的作用域
        // 2.会造成内存泄漏，因为内部函数会保留外部函数的作用域
        // 3.会影响性能，因为内部函数会保留外部函数的作用域
        // 4.会造成变量污染，因为内部函数会保留外部函数的作用域



        // // 闭包经典面试题
        // for(var i=1;i<=5;i++){//同步
        //     setTimeout(function(){//异步
        //         console.log(i)
        //     },1000)
        // }
        // // 原因：setTimeout是异步的，会等到同步代码执行完毕后再执行，此时i已经变成了6
        // // 解决方法：使用闭包
        // for(var i=1;i<=5;i++){
        //     (function(i){//闭包
        //         setTimeout(function(){
        //             console.log(i)
        //         },1000)
        //     })(i)//立即执行函数
        // }
        // // 纯粹的闭包
        // for(var i=1;i<=5;i++){
        //     setTimeout((function(i){
        //         return function(){
        //             console.log(i)
        //         }
        //     })(i),1000)
        // }
        // // 另一种改法
        // for(let i=1;i<=5;i++){//let是块级作用域
        //     setTimeout(function(){
        //         console.log(i)
        //     },1000)
        // }


        // // 计数器困境
        // function fun(){
        //     var num=0;
        //     num++;
        //     console.log(num);
        // }
        // fun();//1
        // fun();//1
        // fun();//1
        // // 原因：每次调用fun函数都会重新声明num变量，导致num变量无法累加
        // // 解决方法：使用闭包
        // function fun(){
        //     let num=0;
        //     return function(){
        //         num+=1;
        //         return num;
        //     }
        // }
        // // 闭包原理：内部函数可以访问外部函数的变量，外部函数不能访问内部函数的变量
        // var result=fun();
        // console.log(result());//1
        // console.log(result());//2

        // // 闭包应用
        // function fun() {
        //     let num = 0;
        //     return function () {
        //         num += 1;
        //         return num;
        //     }
        // }
        // var result = fun();
        // console.log(result());//1
        // console.log(result());//2

        // // 闭包应用
        // for(let i=1;i<=5;i++){
        //     (function(i){   
        //         setTimeout(function(){
        //             console.log(i)
        //         },1000)
        //     })(i)
        // }




        // // 对象创建
        // var obj = {//对象字面量
        //     name: "zs",
        //     age: 20,
        //     // say: function () {
        //     //     console.log("hello");
        //     // }
        //     // 箭头函数
        //     say:()=>{
        //         console.log("hello");
        //     },
        //     sayName: function () {
        //         console.log(this.name);
        //     }
        // }
        // console.log(obj);

        // var obj1 = new Object();//构造函数 不推荐
        // obj1.name = "ww";
        // obj1.age = 18;
        // obj1.say = function () {
        //     console.log("hello");
        // }
        // console.log(obj1);

        // // 构造函数
        // // 主流
        // function Student(name, age) {
        //     this.name = name;
        //     this.age = age;
        //     this.say = function () {
        //         console.log("hello");
        //     }
        // }
        // var obj2 = new Student("zl", 20);
        // console.log(obj2);
        // console.log(obj2.name);
        // console.log(obj2.age);

        // // 类 可有静态属性 静态方法
        // class Person1{//类
        //     static num=100;//静态属性
        //     constructor(name,age){
        //         this.name=name;
        //         this.age=age;
        //     }
        //     say(){
        //         console.log("hello");
        //     }
        // }
        // console.log(Person1.num);
        // var obj3=new Person1("zl",20);
        // console.log(obj3);

        // //原型创建对象
        // function Person(){
        //     this.name="ls";
        //     this.age=30;
        //     this.say=function(){
        //         console.log("hello");
        //     }
        // }
        // console.log(Person);
        // console.log(Person.prototype);
        // Person.prototype.name="zs";
        // Person.prototype.age=20;
        // Person.prototype.say=function(){
        //     console.log("hello");
        // }
        // var obj=new Person();
        // console.log(obj);
        // console.log(obj.name);
        // console.log(obj.age);
        // obj.say();
        // console.log(obj.__proto__);//原型对象




        // // // 原型链
        // const obj = new Object();

        // Object.defineProperty(obj, "name", {
        //     value: "ww",
        //     writable: true,//是否可写
        //     enumerable: true,//是否可枚举
        //     configurable: true//是否可配置
        // })
        // console.log(obj.name);
        // obj.name = "zs";
        // console.log(obj.name);

        // console.log(Object.getOwnPropertyDescriptors(obj, "name"));



        //this 指向

        // function fun(){
        //     console.log(this);       
        // }
        // fun();//window
        // var obj={
        //     name:"zs",
        //     say:function(){
        //         console.log(this);
        //     }
        // }
        // obj.say();//obj
        // var fun=obj.say;
        // fun();//window

        // var f=function(){
        //     console.log(this.x);
        // }
        // var x=100;
        // var obj={
        //     x:200,
        //     f:f
        // }
        // //单独调用
        // f();//100
        // //对象调用
        // obj.f();//200

        // //箭头函数的this指向
        // const fun1=()=>{
        //     console.log(this);
        // }
        // fun1();//window



        //this的指向

        // function Person() {
        //     this.age = 0;

        //     setInterval(() => {
        //         this.age++;
        //         console.log(this.age);
        //     }, 1000)
        // }
        // const person = new Person();

        // function Person1(){
        //     this.age=0;
        //     setInterval(function(){
        //         this.age++;
        //         console.log(this.age);
        //     },1000)
        // }
        // const person1=new Person1();


        // ===================================
        // call的使用

        // var person = {
        //     show: function () {
        //         console.log("我是" + this.name + "，今年" + this.age + "岁了");
        //     }
        // }
        // var obj1 = {
        //     name: "刘备",
        //     age: 20
        // }
        // var obj2 = {
        //     name: "关羽",
        //     age: 30
        // }
        // person.show.call(obj1);
        // person.show.call(obj2);

        // // apply的使用
        // person.show.apply(obj1);
        // person.show.apply(obj2);

        // //bind的使用
        // var fun = person.show.bind(obj1);
        // fun();

        // 预设函数
        // function fun(a, b) {
        //     console.log(a + b);
        // }
        // var fun1 = fun.bind(null, 10);

        // console.log(fun1(20));
        // console.log(fun1(30));

        // ===================================



        //=======================================
        //使用闭包实现私有属性的访问
        // function Person(name,sex){
        //     var name=name;
        // }
        //=======================================

        //=======================================
        // 创建一个对象，创建两个属性，一个类型是number，a，一个类型是Array，b，一个方法，判断a是否在b中，出现返回a在b中的下标，否则返回-1
        //判断类型的方法：typeof
        //判断数组中是否存在某个元素的方法：indexOf
        var obj = {
            a: 4,
            b: [1, 2, 3, 4, 5],
            c: function () {
                return this.b.indexOf(this.a);//indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1
            }
        }
        console.log(obj.c());
        //=======================================
        
    </script>
</body>

</html>